

  **** 指针常量 ******
    本质是常量，指针用来说明常量的类型，表示该常量是一个指针类型的常量。指针自身的值是常量，不可改变，定义时必须初始化：
	int b = 20; int * const p = &b;   *p = 10;
  
  **** 常量指针 ******
    常量指针本质是指针，常量表示指针指向的内容，表示该指针指向的是常量。指针指向的内容不可改变：
	int b = 20; const int *p = 20; 

  ***** const  放在类型或变量左边和右边是等价的 ****
  int * const a; (* 读作 pointer to，从右向左读) 指针不可改变
  const int * a; ()  指针内容不可改变


引用：
	1. 引用必须是合法的空间  &a = 7;是错误的
	2. 引用相当于起别名
	3. 不要返回局部变量的引用， int (&arr)[] = arr1;
	4. 函数的返回值是引用，当左值 ：int& Dotest(){ static int a = 0; return a;}   int main(){Dotest() = 1000;}
	5. 引用的本质： 在C++内部实现是一个指针常量   Type& ref = val;//Type* const ref = &val
	6. 指针的引用  
	   struct Person{int m_Age;};
	   void allocateMemory(Person **p){*p = (Person *)malloc(sizeof(Person));  (*p)->m_Age = 26;}
	   void allocateMemoryRef(Person* &p){p = (Person *)malloc(sizeof(Person)); p->m_Age = 25;}
	   void main(){ *p = NULL; allocateMemory(&p); allocateMemoryRef(p);}
	   
	7. 常量的引用
	
	   int &a = 8; // 非法的
	   int const &a = 6; // 合法  相当于 int tmp = 10; int const &a = tmp;
	   a = 10；// 不合法
	   int *p = (int *)&a;  //利用指针去修改值
	   *p = 20;

    

内联函数： inlineFunction   代替宏函数（宏容易出现一些不容易发现的错误，没有作用域）
	增加关键字 inline
	inline void func();  //声明和实现都要加关键字inline
	
	内联函数相对于普通函数省去了调用时的压栈、跳转、返回的开始，可以理解为空间换时间
	
	类中声明方法时，编译器会默认添加inline关键字
	以下情况不会当作内敛函数处理：1. 任何形式的循环语句
								  2. 过多的判断语句
								  3. 函数体过于庞大
								  5. 不能对函数进行取址操作 （内联函数没有入口地址）
	inline 只是一种建议

	
函数参数   
	占位参数  void func(int )
	函数参数，第n个参数有默认值，后面n+1开始必须都要有默认值
	声明和实现的时候只能有一个参数是默认值，另一个不要有值






函数重载 overload 

	理解： C++中允许出现同名函数，这种现象称为函数重载
			目的是为了方便的使用函数名称
	
	示例： void func(){}
		   void func(int a){}

			2. 引用的重载
			void fun(int &a){}
			void main(){ fun(10);}	// 错误，没有合法空间
			void fun(const int &a){}// 上面语句正确，const会分配内存 int tmp = 10,const int &a = 10;

	注意事项： 1. 作用域应相同，函数名也相同，函数的参数个数不同或类型不同或顺序不同
			   2. 函数的返回值不可以区分条件
			   3. 函数重载注意二义性问题，即含有默认参数 void fun(int a, int b = 10){}  void fun(int a){}
			   4. 引用的重载  ，引用必须有合法的内存空间 	

	实现原理：  编译器自动修饰函数名，比如：void fun(): _fun(); void fun(int a) :fun_int; 


C++ 中使用c语言 ，1. 在C++中使用 extern "C" void fun();  // 不要加头文件，会有冲突
				  2. 在c文件中使用   #ifdef __cplusplus  
									 extern "C" {
									 #endif
									 
									 void func();
									 
									 #ifdef __cplusplus
									 }
									 #endif
					 


struct 和 class 在c++中是一样的，唯一的区别是struct 默认是public ， class 默认是private

	private ：  方法和属性，在类的外部不可以访问，子类也不行
	protected： 当前类的子类可以访问，类外部不可以访问，
	public:	    方法和属性，在类的外部可以访问


成员函数定义的时候加const，表示其不会修改属性值。 void func() const{ }


构造函数 ：

	class Person
	{
		public：
		// 与类名相同，没有返回值，不写void，可以重载，程序自动调用，只会调用一次
		Person()
		{
			cout<<"构造函数"<<endl;
		}
		// 与类名相同，前面增加一个符号"~"，没有返回值，不写void，不能有参数，只调用一次
		
		// 拷贝构造函数,必须有const
		Person(const Person &p)
		{
			cout<<"拷贝构造函数"<<endl;
		}
		
		Person(int a)
		{
			cout<<"有参数构造函数"<<endl
		}
		~Person()
		{
			cout<<"析构函数"<<endl;
		}
	}

	分类：无参构造函数，有参构造函数 
		  普通构造函数，拷贝构造函数 

	构造函数必须写在public 下，才能调用到


	使用默认构造函数，不要加 (),例如 Person P2();// 不对，不要带括号，带括号会认为是函数声明

	Person p1 = Person(100);
	Person(30);		// 匿名构造函数，这行代码执行完成就会释放对象
	Person(p1); 	// 不能使用拷贝构造函数初始化匿名对象，这里编译器认为 Person p1，重复定义
	Person p3 = 100; // 相当于 Person p3 = Person(100)  隐式类型转换



	拷贝构造函数调用的时机： 1. 用创建好的对象来初始化新的对象
							 2. 以值传递的方式给函数参数传值   void do(Person P1){}  Person p; do(p);
							 3. 以值的方式返回局部对象   void do(){ Person p1; return p1;}   Person p = do();

	
	系统默认提供三个函数： 默认构造，拷贝构造，析构函数。
	
	如果自定义了有参构造，系统不在提供默认构造。
	如果自定义了拷贝构造，系统不在提供其他构造函数



深拷贝和浅拷贝

	class Person
	{
		private:
		
		char* m_Name;
		int m_Age;
		
		public:
		Person( char *name,int age)
		{
			m_Name = (char *)malloc(strlen(name) + 1);
			strcpy(m_Name,name);
			m_Age = age；
		}
		// 系统默认提供的拷贝函数为浅拷贝
		Person(const Person &p)
		{
			m_Name = p->m_Name;
			m_Age = p->m_Age;
		}
		//自定义 深拷贝
		Person(const Person &p)
		{
			m_Name = (char *)malloc(strlen(p.m_Name) + 1);
			strcpy(m_Name,p.m_Name);
			m_Age = p.m_Age;
		}
		// 自定义深拷贝后，需要把堆区的m_Name释放掉
		~Person()
		{
			if(m_Name != NULL)
			{
				free(m_Name);
				m_Name = NULL;
			}
		}
		
	}
	


利用初始化列表初始化数据

	class Person
	{
		int m_A;
		int m_B;
		int m_C;
		//利用初始化列表初始化数据
		// 构造函数后面 + :属性(参数)，属性(参数)...	
		Person(int a, int b, int c):m_A(a),m_B(b),m_C(c)
		{
			
		}
		
	}


类对象为类成员时，构造顺序：将类对象构造，然后构造自身。析构是相反的


防止隐式类型转换  Person p = 10; //Person p = Person(10);
	声明构造函数时，添加explict Person(int a); Person p = 10;// 会报错



new 运算符和delete运算符
	new： 创建一个类型指针 Person *p = new Person
		  默认返回一个有类型的指针，不需要强转
	delete： 删除对应的，调用析构函数
	
	new： 使用void * 去接受new开辟的指针，使用delete不能释放，要避免
	new 创建的数组，delete 删除语法：delete [] array
	malloc 是函数，返回void指针，需要强转，且不会调用构造函数
	





----------------------------Day  4--------------------------

静态成员变量 
	1. 所有对象共享一个静态成员变量
	2. 在编译期间，对象还没创建时，就已经给静态成员变量分配好内存了。
	3. 类内声明，类外初始化。
	4. 静态成员变量也是有权限的。
	5. 放在全局区
	
	class Person 
	{
		public:
		static int Age;
		static void Fun()
		{
			cout<<"static func "<<endl;
		}
		
		private:
		static int otherManNum;
	}
	int Person::Age = 0;
	int Person::otherManNum = 0; // 这里是初始化，可以访问，但是其他地方不能访问


静态成员函数

	1. 与静态成员函数一样
	2. 不可以访问普通的成员变量,没办法区分谁是谁
	3. 可以访问静态成员变量
	4. 静态成员函数也是有权限
	5. 普通成员函数可以访问静态，也可以访问普通
	6. 访问方式可以通过对象，也可以通过类名




单例模式：

	是一种软件设计模式，在它的核心结构中只包含一个称为单例的特殊类。单例模式可以保证系统
	中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。

	为了防止外部对其初始化，将其默认构造和拷贝构造设为私有

	class ChairMan
	{
		private:
		// 构造私有化
		ChairMan(){}
		ChairMan(const ChairMan &C){}
		// 使用静态变量创建唯一实例
		static ChairMan* singleMan;
		
		public:
		//提供唯一访问接口
		static ChairMan* getInstance()
		{
			return singleMan;
		}
	}
	ChairMan * ChairMan::singleMan = new ChairMan;


	创建步骤：
	1. 私有化 默认构造和拷贝构造
	2. 内部维护一个对象指针，类外初始化
	3. 私有化唯一对象指针
	4. 对外提供getInstance方法来访问这个指针


	打印机案例
	class Printer
	{
		private :
		int m_Cnt;
		
		Printer(){m_Cnt = 0;}
		Printer(const Printer &p){}
		static Printer* SinglePrinter;
		
		public:
		Printer * getInstance()
		{
			return SinglePrinter;
		}
		void printText(string text)
		{
			cout<< "打印内容为："<<text<<endl;
			m_Cnt++;
			cout<<"打印机使用了 "<<m_Cnt<<" 次"<<endl;
		}
	}
	Printer* Printer::SinglePrinter = new SinglePrinter;



	C++ 看起来是将成员函数与成员变量封装起来，但是存储依然是分开的
	C++ 中的非静态数据成员直接含在类对象中，就像C的Struct一样
	成员函数虽然在clss声明，却不出现在对象中
	每一个非内联成员函数，指挥诞生一个函数实例。可以用this指针区分不同实例
	成员属性和函数是分开存储


	class Person{}
	空类的大小为1 ，sizeof(Person) == 1,  每一个实例对象都有一个独一无二的地址，char维护这个地址，所以大小为1


	class Person
	{
	public:
		int a;			// 非静态成员属性属于对象
		static int b;	// 静态成员变量，不属于对象

		void func();	//非静态成员函数，不属于对象
		static void func1();	// 静态成员函数，不属于对象
		// double c;  	// sizeof(Person) = 16 ,double = 8, int 会补齐为8
	}
	sizeof(Person) = 4;


  
  
this 指针
	
	this指针指向被调用成员函数所属的对象，用于保存对象的地址
		非静态成员函数独享，静态成员函数没有this指针
	class Person
	{
		void fun(Person * this); // 系统默认会增加，隐含在非静态的成员函数
	}


	class Person
	{
	public:
		Person(age)
		{
			this->age = age;
		}
		int age;
		
		Person &PlusAge(Person &p2)			// 注意这里是引用，如果不是引用，返回的方式是通过拷贝构造，返回的不是对象P1，拷贝的东西
		{
			this->age += p2.age;
			return *this;		// 链式编程方式，返回对象本身
		}
	}

	Person p1(10);
	Person p2(20);
	
	p1.PlusAge(p2).PlusAge(p2);


空指针访问成员函数

	class Person 
	{
	public:
		int age;
		int Info;
		// 就算是常函数，仍然可以修改
		// 增加关键字mutable
		mutable int mutable_tmp;
		void show()
		{
			cout<<"show your name"<<endl;
		}
		
		void showage()
		{
			if(this == NULL)
			{
				return;
			}
			cout<<"show age :"<<age<<endl; // 相当于 NULL->age ，所以会出错
		}
		void showinfo() const // 常函数，内部不允许修改指针指向的值
		{
			this->Info = 100; // 错误的，不允许修改，相当于const Person  * const this
			this->mutable_tmp = 1000; // 可以，因为增加了mutable 关键字
			cout<<"Info "<<endl;
		}
	}

	void main()
	{
		Person *p = NULL;  // 相当于 this = NULL
		p->show();	// 没问题，因为没有用到this
		p->showage();// 会报错，因为用到this
		
		const Person p1; // 常对象，不允许修改属性
		// 常对象不能调用普通函数，只能调用常函数
	}
	



友元  

	C++会把私有函数“藏起来”，禁止外部访问，但是有时候需要访问私有成员，解决方法就是友元函数，是一种特权

	可以把全局函数,某个类中的成员函数,甚至整个类声明为友元,三种方式:
	
	1. 全局函数
	class GoodGay
	{
		void visit();
		
		Buidling * building;
	}
	
	
	class Building
	{
		// 让好基友类作为友元类
		friend class GoodGay;
		
		// 让全局的好基友函数,变成我的好朋友  友元函数
		friend void goodGay(Building * building);
		public:
		
		Building()
		{
			this->m_SittingRoom = "客厅";
			this->m_BedRoom = "卧室";
		}
		// 好基友的成员函数作为我的友元函数,也可以在外部实现
		friend void GoodGay::visit()
		{
			cout<<"这是友元成员函数"<<endl;
		}
		
		string m_SittingRoom;
		
		private:
		string m_BedRoom;
	}

	// 全局函数
	void goodGay(Building * building)
	{
		cout<<" 好基友正在我的"<< building->m_BedRoom <<endl;
		cout<<" 好基友正在我的"<< building->m_SittingRoom <<endl;
	}
    
	
	2. 让整个类做 友元类
		friend class 类名
		友元类是单向的,不可传递
		
		
	3. 让成员函数作友元
	
		





**************** DAY  5*********************

运算符重载：

	就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

	operator@   @ 表示运算符 
	
	提供全局函数、成员函数
	
	对于内置数据类型表达式的运算符是不可改变的
	

	左移运算符 << 不能写在成员函数里


    一般而言：符号重载 前置运算符返回引用，后置运算符返回值
	operator++();   operator++(int);后置

	智能指针，用来托管自定义类型的对象，让对象进行自动的释放
	

	一个类会默认创建4个函数：默认构造，拷贝构造，析构函数，operator= 重载（简单值传递）


    重载：
	=  [] () -> 只能通过成员函数重载
	<<  >>  只能通过全局函数+ 友元函数进行重载
	不要重载 && 与 || 操作符，因为无法实现短路规则



继承  

	// 下面继承方式均不可访问父类private 
	class  subclass : public fathorclass {}		// 保持父类的权限
					  protected fathorclass{}	// 除父类私有属性，其他均为protected
					  private fathorclass{}     // 除父类私有属性，其他均为private



	如果父类中没有合适的构造，子类中可以利用初始化列表，显示调用有参构造
	class base
	{
		public:
		base(int a){
			this->m_A = a;
		}
		int m_A;
	}
	
	class son:public base{
		public:
		son(){} // 报错了,调用父类的中的默认构造时，发现没有定义
		son(int a) : base(a){}	// 子类构造时，会初始化父类中的值
	}



	1.  继承中，父类先构造，然后在构造子类，析构时，先析构子类，然后析构父类

	2.	子类会继承父类的成员函数，属性
			但是，子类不会继承父类的   构造和析构函数，operator=
			只有父类自己知道如何构造和析构自己的属性

	3. 子类没有提供的函数和属性，会继承父类中的
	   子类与父类拥有重名的函数、属性，子类不会覆盖父类的成员，\
	   子类与父类拥有重名的函数、子类增加自己特有的重名内容，隐藏父类内容，包括重载
	   想调用父类的方法必须增加作用域，son.fathor::func()
	
	4. 继承中静态成员的处理
	   可以继承，类似非静态成员函数
	
	5. 多继承   class son :public fathor1,public fathor2{}
		多继承中注意二义性，两个父类中有重名成员，调用基类然后在调用成员名避免冲突，作用域
		
	6. 菱形继承，容易造成资源浪费     动物(age) -> 羊(age)、驼(age)-> 草泥马(age) ，
	
	   使用虚继承解决该浪费 class sheetTuo: virtual public Sheet{}  class sheetTuo: virtual public Tuo{}
	   sheetTuo内部结构是：vbptr：V:virtual ,b:base ,p:pointer  vbttr:虚基类指针，指向一张虚基类表，通过表找到地址偏移量，找到公有数据
	





******************DAY  7   **************

多态 

	抽象、继承、多态 三个基本特性
	
	多态性polymorphism 提供接口与具体实现之间的另一层隔离。改善代码的可读性和组织性，同时也使创建的程序具有可扩展性。

     静态多态：编译时多态，比如函数重载和符号重载

	 动态多态：运行时多态，比如派生类和虚函数运行实现多态
	
	静态多态与动态多态的区别：
		就是函数地址是早绑定(静态联编)还是晚绑定(动态联编)；
		函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态(编译时多态)，早绑定
		如果函数的调用地址不能编译，不能在编译期间绑定，在运行时才能确定，就是动态多态
		
·



	如果发生了继承关系，编译器允许进行类型转换。
	
	1. 动态多态就是虚函数，继承关系
	2. 静态多态，函数重载，符号重载
	3. 静态联编 地址早绑定，编译阶段绑定好地址
	4. 动态联编， 运行时绑定好地址
	5. 多态：父类的引用或指针指向子类对象


	举例：
	
	class Animal{
	public:
		virtual void speak() 	// 使用virtual关键字 ,sizeof(Animal) = 4,内部有指针vfptr，虚函数表指针，会指向一个表
		{						// 指向Animal::speak 函数的地址
			cout<< "Animal speak!"<<endl;
		}
		
	}
		
		
	class Cat:public Animal{
	public:
		void speak()		//可使用virtual，也可不使用，子类会"重写"父类的虚函数，函数返回值，参数都一样
		{
			cout<< "Cat speak!"<<endl;
		}
		
	}
	
	void doSpeak(Animal & ani)
	{
		ani.speak();
	}

	void main()
	{
		Cat cat;
		doSpeak(cat); // 多态，动态多态，输出是 Cat Speak，如果在父类中没有加virtual，输出为Animal speak
		
		Animal * animal = new Cat;
		animal.speak(); // 发生多态，调用的是Cat的speak
 	}



	实际开发过程中，有开发原则和关闭原则；
	对扩展开放，对修改关闭
	
	
	多态有利于后期扩展，结构性好，可读性高，多态的效率稍微低一点点。多了一个指针


	// 虚函数 
	virtual int getResult() {return 0;}
	// 纯虚函数
	virtual int getResult() = 0;
	
	// 子类继承中，必须实现父类的纯虚函数。
	// 父类中有纯虚函数，就不能实例化对象了
	// 父类中有了纯虚函数，被称为抽象类，就不能实例化对象了


    虚析构   
	
	在继承过程中，发生多态了，析构过程中，Animal *ani = new Cat; delete ani; 会释放不干净
	
	父类对象指向子类对象时，会释放不干净，需要给父类的析构加Virtual ~Animal(){}
	

	纯虚析构  virtual Animal() = 0;
	
		必须实现，类内声明，类外实现
		
    如果有了纯虚析构，也是抽象类，不能实例化对象
	
	基类 <= 派生类
	
	没有发生多态时：
		向下类型转换，不安全： Animal *ani = new Animal;
								Cat * cat = (Cat*)ani;
		基类强转派生类不安全
	
		反之安全，向上类型转换，派生类转换基类，安全
		
	发生多态时： 向上向下都安全
	
		Animal *animal = new Cat;  // 申请的空间为Cat ，是大于Animal的，所以安全
	







第二部分   C++ 模板

  C++提供了函数模板(function template) 所谓函数模板，实际上是建立一个通用函数， 
  其函数类型和形参类型不具体制定，用一个虚拟的类型来代表。这个通用函数称为函数模板
  凡是函数体相同的函数都可以用这个模板代替，不必定义多个函数，秩序在模板中定义
  一次即可，在调用函数时，系统会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能。
  
  C++ 提供函数模板 和 类模板
  
  类属：类型参数化，又称参数模板

   函数模板：
   
   // 类型参数化 ，泛型编程 -- 模板技术
   格式： template <class T> //告诉编译器下面出现T不要报错，T是一个通用类型
		  void mySwap(T &a, T &b)
		  {
			T tmp = a;
			a = b;
			b = tmp;
		  }
		  
		  int a_int = 10;
		  int b_int = 20;
		  mySwap(a_int,b_int);  // 自动推导,必须有参数类型才能推导
		  mySwap<int>(a_int,b_int); // 显示指定类型
		  
		  double a_double = 1.3;
		  double b_double = 3.14;
		  mySwap(a_double,b_double);
	template <class T>			// 两种方式都可以
	template <typename T>		

	注意T的类型只能是同时只能是一种
	char a_char = 'a';
	mySwap(a_char,b_int); // 会报错

	// 模板必须指定T才能使用，不然不能分配内存

    ## 函数模板与普通函数的区别
	1. 普通函数可以进行隐式类型转换，函数模板不行
	2. 如果出现重载，优先使用普通函数，强制调用模板函数 func <> ();
	3. 函数模板也可以发生重载
	4. 如果函数重载可以产生更好的匹配，优先调用函数模板
	
	
	编译器并不是把函数模板处理成能够处理任何类型的函数(自定义的)
	通过模板生成的函数称为模板函数（对于具体的类型产生不同的函数）
	编译器对函数模板进行2次编译，在声明的地方对模板本身的代码进行编译，热河调用的地方对参数替换后的代码进行编译
	
    模板的局限性：a>b 时，假如a是数组
	class Person {}
	template <class T> bool myCompare(T &a, T &b){}
	// 匹配自定义类型，如果具体化能够优先匹配，那么就选择具体化
	template <> bool myCompare<Person>(Person &a,Person &b)
	
	
	
	类模板
	template <class NameType, class AgeType>
	class Person
	{
		public:
		Person(NameType name, AgeType age)
		{
			this->m_Name = name;
			this->m_Age = age;
		}
		NameType m_Name;
		AgeType = m_Age;
	}

	// 类模板不支持自动类型推导
	// 类模板可以有默认参数  template <class A = int>
	Person<string, int>p1("五天",10);
	
	// 成员函数一开始不会创建，运行时才会创建
	
	
	
	
	## 参数模板化
	
	传入参数的三种方式：
	1. 指定类型传入  void fun(Person<string, int >&p){}
	2. 参数模板化   template<class T1, class T2>
					viud fun(Person<T1,T2> &p){}
					
	3. 整体模板化  template <class T>
				   void fun(T &p){ typeid(T).name() /* 查看类型*/}  
	
	
	类模板中的继承：
	
	1.子类继承父类时，必须指定父类的模板T的类型，否则无法分类内存
	2. 子类可以通过参数列表向父类传递参数
	
	template <class T>
	Class  Base
	{
		public:
		T m_B;
	}
	
	class child1 : public Base<int> // 这里必须指定类型
	{
		
	}
	
	template <class T1, class T2>
	class child2 : public Base<T2>
	{
		T1 m_A;
	}
	//T1 是int类型，Base类中T 是Double类型
	Child2 <int, double> chd;

	
	3. 类外实现类模板成员函数
	template <class T1,class T2>
	Child2<T1,T2>::Child2(T1 name, T2 age)
	{
		this->name = name;
		this->age = age;
	}

	4. 类模板的分文件实现(.h和.cpp文件)
		头文件中声明，.cpp中实现(所以类型是在.cpp 中确认)
		在其他文件中#include ".h"时，模板类型不确定，会报链接错误
		这是因为模板类的成员函数在运行时才会创建，只包含.h不会创建
		因此，#include".cpp"，可以解决，但是不建议这么做
		
		将类声明和实现放在一个文件中，将文件名的后缀改为.hpp。模板文件
	
	5. 友元函数类内实现
	
	template <class T1,class T2>
	
	class Person
	{
		friend void printInfo(Person<T1,T2> &p)
		{
			cout<< "姓名：" << m_Name <<", 年龄："<< p.m_Age <<endl;
		}
	public:
		Person(T1 name, T2 age)
		{
			this->m_Name = name;
			this->m_Age = age;
		}
	private:
		T1 m_Name;
		T2 m_Age;
	}
	
	// 改友元函数默认为全局函数
	Person<string, int >("Tom", 2)p;
	printInfo(p);


	6. 友元函数类外实现


	// 必须让编译器先看到声明，不然不知道是什么(类，函数)
	template <class T1,class T2>class Person;
	template <class T1,class T2>void printInfo(Person<T1,T2> &p)
	template <class T1,class T2>
	
	class Person
	{
		// 注意这里时普通函数声明，与外部声明的模板函数不一致，会覆盖外部声明的友元模板函数
		friend void printInfo<>(Person<T1,T2> &p); // 加<> 说明时模板
		/*{
			cout<< "姓名：" << m_Name <<", 年龄："<< p.m_Age <<endl;
		}*/
	public:
		Person(T1 name, T2 age)
		{
			this->m_Name = name;
			this->m_Age = age;
		}
	private:
		T1 m_Name;
		T2 m_Age;
	}
	
	template <class T1, class T2>
	friend void printInfo(Person<T1,T2> &p); // 加<> 说明时模板
	{
		cout<< "姓名：" << m_Name <<", 年龄："<< p.m_Age <<endl;
	}
	// 改友元函数默认为全局函数
	Person<string, int >("Tom", 2)p;
	printInfo(p);






********************** DAY 9 ************************

类型转换

1. 静态类型转换

static cast 用于类层次结构基类和派生类之间指针或引用的转换
    向上类型转换，安全
	向下类型转换，不安全：
	
	例子： char a = 'a';
		   double b = static_cast<double>(a);
		   cout<< "b = "<< b <<endl;

		   // 转换类时，必须是父子关系才能转换
		   static_cast<目标类型>(原始对象)
		   // 使用引用和指针都可以转换

2. 动态转换 dynamic_cast 

	基础类型不可以转换
	非常严格，失去精度或者不安全都不可以转换
	
	//如果发生了多态，就可以使得父类对象转换为子类对象，向下类型转换
	//如果发生了多态，向下和向上类型转换都是安全的。



3. 常量转换 const_cast 

	该运算符用来修改类型的const属性
	常量指针转换为非常量指针，并且仍然指向原来的对象
	常量引用被转换为非常量引用，并且仍然指向原来的对象
	
	注意：不能直接对非指针或非引用的变量使用const_cast操作符区直接移除它的const
	
	例子：
	
	const int * a = 1;
	int * b = const_cast<int *>(a);
	
	int *c = 1;
	const int *d = const_cast<const int *>(c);
	
	
	
3. 重新解释转换(reinterpref_cast)

	最不安全的一种转换机制，最有可能出现问题，不推荐
	
	主要用于将一种数据类型从一种类型转为另一种类型，它可以将指针转换为
	证书，也可以将一个整数转换为指针，也可以将毫不相关的类互相转换。

4. 异常

	语法：
	
	int myDevide(int a, int b)
	{
		if(b == 0)
		{
			throw -1; // int 类型异常
		}
		// 异常一定要处理，不处理会崩溃
		return a/b;
	}
	int a = 10,b = 0;
	try
	{
		myDevide(a,b);
	}
	catch(int)
	{
		cout<< "int 类型异常" << endl;
		// 如果不想处理，继续抛出
		throw;
	}
	catch(double)
	{
		cout<< " double 类型异常" << endl;
	}
	catch(...) // 其他类型的
	{
		cout<< "其他类型异常" <<endl;
	}
	
	// 如果异常没有处理，程序会调用terminate函数，中断程序 
	
	
	自定义异常：
	class myException
	{
		void printError()
		{
			cout<< " 自定义异常 " <<endl;
		}
	}
	
	throw myException(); // 匿名对象
	
	try 
	{
		error;
	}
	catch(myException e)
	{
		e.printError();
	}


	栈解旋： 从try 开始，到throw 抛出异常之前，所有栈上的对象，都会被释放，这个过程被称为栈解旋。
	
	异常的接口声明： throw 与 catch的严格对应，可以将异常函数封装
	void func() throw(int)// throw(int) 只能抛出int类型异常
	{
		throw 1;
	}
	
	void func() throw() // 不能抛出任何异常 ,会报错
	{
		throw 1;
	}

	void func() throw(int, double, char) //  可以抛出三种类型的异常
	{
		throw "aaa";
	}
	
	异常的声明周期
	
	class myException()
	{
		
	}
	
	void doWork()
	{
		throw myException();
		throw new myException(); // 创建到堆上
	}
	
	try
	{
		doWork();
	}
	catch(myException &e) // myException e 会调用拷贝构造，会多一份内存消耗
	{
		
	}
	catch(myException *e) // 应对创建在堆上的
	{
		delete e;
	}


	异常和多态的使用
	发生多态后，调用的还是子类，系统实现的方式也是多态

	使用系统的标准异常
	#include <stdexcept>
	
	写自己的标准异常,只关注virtual 部分
	class myexcept :public exception
	{
	public:
		string m_ErrorInfo;
		myexcept(string errorinfo)
		{
			this->m_ErrorInfo = errorinfo;
		}
		virtual ~myexcept()
		{
		
		}
		virtual const char * what() const
		{
			//返回错误信息
			return this->m_ErrorInfo.c_str();
		}
	}

	throw myexcept("My errorInfo");

5. 输入输出流
	
	标准输入流
	
	cin.get() 			// 一次只能一个字符
	cin.get(一个参数) 	// 读一个字符
	cin.get(两个参数) 	// 可以读字符串（字符串和长度）,不会把缓冲区的换行符拿走
	cin.getline(buf,buf_len)	// 把换行符从缓冲区取走了 
	cin.ignore()		//  忽略一个字符(加入参数n,代表忽略n个字符)
	cin.peek()			// 查看缓存内容，不会取走
	cin.putback()		// 调用cin.get() 拿走缓存区内容之后，然后放回
	
	如果要求是 int 类型，然而输入的是char，会破坏输入标志位cin.fail(),一直存在，一直拿到的为错误值，导致异常
	cin.clear(); 	// 重置标志位
	cin.sync(); 	//清空缓冲区


	标准输出流：
	字符输出
	cout.flash() // 刷新缓冲区
	cout.put() // 向缓冲区写字符
	cout.write() // 从buffer中写入num个字节到当前输出流中
	
	
	cout.put('H');		// 输出H
	char buf[1024] = "hello world!";
	cout.write(buf,strlen(buf)); // 输出 buf内容
	
	// 格式化输出
	# 通过流成员函数
	int number = 99;
	cout.width(20);   
	cout.fill('*');
	cout.setf(ios::left); //设置格式状态
	cout.unsetf(ios::dec); // 取消设置
	cout.setf(ios::showbase); // 强制输出整数基数
	
	# 控制符格式化 
	#include<iosmainip>
	int number = 10;
	cout << setw(20)
		 << setfill('*')
		 << endl;


	文件的读写
	三个类：ifstream,ofstream,fstream
	
	
	#include<fstream>
	
	// ios::trunc 如果有，就删除其内容，不存在就创建
	ofstream ofs("./test.txt",ios::out | ios::trunc);
	
	ofstream ofs;
	if(ofs.open("./test.txt",ios::out | ios::trunc);)
	{
		ofs <<""<<endl;
		ofs <<""<<endl;
	}
	else
	{
		cout<<"打开文件失败"<<endl;
	}
	
	ifstream ifs;
	ifs.open("./text.txt",ios::in);
	if(ifs.is_open())
	{
		char buf[1024];
		while(ifs>>buf)
		{
			cout<<buf;
		}
		
		// 2
		char buf2[1024];
		while(!ifs/eof())
		{
			ifs.getline(buf2,sizeof(buf2));
			cout<<buf2;
		}
		
		//3
		char c;
		while((c = ifs.get()) != EOF)
		{
			cout<<c;
		}
	}
	
	ifs.close();




*************** DAY 10 ****************

STL  Standard Template Libary 标准模板库

	从广义上分为： 容器container,算法algorithm,迭代器iterator
	容器和算法之间通过迭代器无缝连接。
	
	STL ：提供了6大组件，分别是容器，算法，迭代器，仿函数，适配器，空间配置器。
	
		容器：各种数据结构：vector,list,deque,set,map 等，STL容器就是一种class template
		算法：常用算法： sort, find, copy, for_each
		迭代器：扮演容器与算法之间的桥梁，从实现角度来看，迭代器就是将一种
			    operator*,operator++,operator--,operator->等相关操作重载的calss template 
				所有的STL容器都有自己专属的迭代器，只有容器设计者才知道如何遍历自己的元素，原生指针也是一种迭代器
		仿函数：行为类似函数，可作为算法的某种策略，从实现角度来看，仿函数是一种重载了operator()的class或者class template
		适配器： 一种用来修饰容器或者仿函数或迭代器接口的东西。
		空间配置器：负责空间的适配和管理。从实现角度来看，配置就是一个实现了动态空间配置，空间管理，释放的class template 
		
	STL6大组件之间的关系： 容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，
			仿函数可以协助算法完成不同的策略变化，适配器何以修饰仿函数。
		
	优点：1. 将数据与操作分离，数据由容器类别加以管理，操作由可定制算法定义，迭代器在两者之间当“粘合剂”	，使得容器与算法交互运作
		  2. STL 高可重用性，高性能，高移植性，跨平台。

	
	容器： 分为序列式容器，关联式容器
	
			序列式： 强调值的排序 ，queue，vector，list
			关联式： 非线性的树结构(二叉树)，各元素之间没有物理上的顺序关系，
					 即元素在容器中并没有保存元素置入容器时的逻辑顺序，特点有：key ：value
					 set/multiset  Map/multimap
					 

    算法：  分为质变算法，非质变算法
		
		质变算法：是指运算过程中会改变区间内的元素的内容，例如拷贝、替换、删除等
		非质变算法：是指运算过程中不会改变区间内元素的内容，例如查找，计数，遍历，寻找极值等。
		

	迭代器： 一种方法，依次访问容器中的各个元素，而又无需暴露容器内部的表示方式。
	
		种类：输入迭代器    只读，支持::, ==, !=
			  输出迭代器    只写，支持++
			  前向迭代器	读写，支持++,==,!=
			  双向迭代器	读写，支持++,--
			  随机访问迭代器  读写，支持++, --,[n],-n,<,<=,>=,>
		可以理解为一种指针。
		
		
	// 普通指针
	int arr[] = {1,2,3,4,5};
	int *p = arr;
	for(int i = 0;i < 5;i++)
	{
		cout << arr[i] << endl;
		cout << *(p++) <<endl;
	}
	
	
	// vector 
	#include <vector>
	
	vector<int> v; // 声明容器类型为int，即模板方式
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	// 利用迭代器，遍历容器中的内容
	vector<int>::iterator itBegin = v.begin();  // itBegin 指向容器起始位置,第一个数据
	vector<int>::iterator itEnd = v.end();		// itEnd指向容器末端，最后一个数据的下一位
	
	// 第一种方式
	while(itBegin != itEnd)
	{
		cout << *itBegin <<endl;
		itBegin++;
	}
	
	// 第二种方式
	for(vector<int>::iterator it = v.begin();it! = v.end();i++)
	{
		cout << *it <<endl;
	}
	
	// 第三种，利用系统提供算法方式
	#include<algorithm>
	void MyPrint(int dataTmp)
	{
		cout << dataTmp <<endl;
	}
	for_each(v.begin(),v.end(),MyPrint);
	
	# 操作自定义类型
	class Person
	{
	public:
		Person(string name, int age)
		{
			this->m_Name = name;
			this->m_Age = age;
		}
		string m_Name;
		int m_Age;
		
	}
	
	vector<Person> v;
	Person p1("小明",10);
	Person p2("小红",11);
	v.push_back(p1);
	v.push_back(p2);
	
	for(vector<Person>::iterator it = v.begin();it != v.end();it++)
	{
		cout<<"姓名："<<(*it).m_Name<<"，年龄："<<it->m_Age<<endl;
	}
	
	// 存放自定义类型的指针
	vector<Person *> v
	v.push_back(&p1);
	v.push_back(&p2);
	for(vector<Person>::iterator it = v.begin();it != v.end();it++)
	{
		cout<<"姓名："<<(*it)->m_Name<<"，年龄："<<(*it)->m_Age<<endl;
	}
	
	//容器可以嵌套
	vector<vector<int>> v;
	vector<int>v1;
	vector<int>v2;
	vector<int>v3;
	for(int i = 0; i < 5; i++)
	{
		v1.push_back(i);
		v2.push_back(i+10);
		v3.push_back(i+100);
	}
	v.push_back(v1);
	v.push_back(v2);
	v.push_back(v3);
	
	for(vector<vector<int>>::iterator it = v.begin();it != v.end();it++)
	{
		for(vector<int>::iterator vit = (*it).begin();vit != (*it).end();vit++)
		{
			cout<<*vit<<" ";
		}
		cout<<endl;
	}
	
	
	
	string 容器：
	
	string 与char * 对比
		1. char* 是一个指针，string是类，string封装了char*，管理这个字符串，是一个char*的容器
		2. string封装了很多实用的成员方法。查找find，copy，delete，insert等
		3. 不用考虑内存释放和越界
		
	// string 的构造
	string() 
	string(const string& str)//拷贝构造
	string(const char* s)// 字符串初始化
	string(int n, char c)//使用n个字符c初始化
	
	// 基本赋值
	string& operator=(const char*s)
	string& operator=(const string &s)
	string& operator=(char c);
	string& assign(const char *s)
	string& assign(const char*s ,int n) // 把s的前n个赋值给当前字符串
	string& assign(const string &s)
	string& assign(int n, char c)//把n个字符c赋值给当前字符
	string& assign(const string &s,int start,int n)//将s从start开始的n个字符赋值给字符串
	
	// string 的获取方式，存取字符操作
	char& operator[](int a);
	char& at(int n);// string a = "hello "; a.at(2) == 'l';
		区别：[]访问越界，会挂掉，at会抛出异常。
		
	// string 拼接操作
	string& operator+=(const string& str);
	string& operator+=(const char* s);
	string& operator+=(const char c);
	string& append(const char* s);
	string& append(const char* s, int n);// s的前n个字符拼接到当前字符串
	string& append(const string& str);
	string& append(const string &s,int pos,int n);// 把字符串s从pos开始的n个字符拼接到当前字符串结尾
	string& append(int n, char c);
	
	
	// 查找和替换(rfind和find内部查找顺序相反)
	int find(const string& str,int pos = 0) const; 从pos开始查找str第一次出现的位置
	int find(const char *s,int pos = 0) const ;
	int find(const char* s,int pos, int n) const; 从pos的位置找s的前n个字符第一次出现的位置
	int find(const char c, int pos = 0) const ;
	int rfind(const char *s,int pos = npos) const;// 查找s最后一次出现的位置
	int rfind(const string& str,int pos = npos) const;
	int rfind(const char *s, int pos, int n);
	int rfind(const char c, int n); //  查找字符c最后一次出现的位置
	string& replace(int pos, int n, const string& str); // 替换从pos开始n个字符为str
	string& replace(int pos, int n, const char* s);
	
	// 字符串比较
	compare 函数在> 时返回1， < 时返回-1， == 时返回0，比较区分大小写
	int compare(const string &str);
	int compare(const char* s);
	
	// 子串 
	string substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串
	
	// 插入和删除 insert and delete

	string& insert(int pos, const char* s);
	string& insert(int pos, const string& s);
	string& insert(int pos, int n, char c);// 指定位置插入n个c
	string& erase(int pos, int n = npos);// 删除pos 开始的n个字符
	
	// string 和 c-style 字符串转换 ，
	// string不可以隐式转换为char* 类型，反之可以
	str.c_str(); // string 转 char*
	string(s);   // char * 转 string
	
	// 如果一个字符重新赋值超出长度(初始化)会重新分配内存，
	string str = "hello ";
	
	char &a = str[2];
	
	str = "hello world!";
	
	a = '3';// 会报错，因为str已经重新分配内存，若长度小于初始化长度则没问题
	
	
	// 字符变大写和小写
	toupper();tolower();
	
	
	
	
	vector 容器：
		与array相比，容量是动态的，可以动态增加
	
		可以使用成员函数vector.capacity()查看容量，容量不够时，会将数据拷贝到新的内存再申请
		********************** 重要 *****************
		所谓动态增加大小，并不是在原空间之后接新空间，因为无法保障原空间之后尚有可用的空间，
		而是一块更大的内存空间，将原数据拷贝到新空间，并释放原空间。因此，对vector的任何操作，
		一旦引起空间的重新分配，指向原vector所有迭代器就失效了
	
	
	容器vector的构造
	vector<T> v;
	vector(v.begin(),v.end());
	vector(n,elem); // 将n个elem拷贝给本身
	vector(const vector &vec);
	
	例如：
		vector<int> v;
		int arr[] = {1,2,3,4};
		vector<int> v1(arr,arr+sizeof(arr)/sizeof(int));
		vector<int> v2(v1.begin(),v1.end());
		vector<int> v3(10,100); // 10个100
		
		
	// 常用赋值
	assign(begin,end); // 将[begin,end)区间的数据拷贝给本身
	assign(n,elem); 	// 将n个elem拷贝赋值给本身
	vector& operator=(const vector& vec);
	swap(vec);   // 将vec与本身元素交换
	
	例如：
		vector<int> v4;
		v4.assign(v3.begin(),v3.end());
		v4.swap(v2); // v4 与v2交换
		
	size(); //容器元素的个数
	empty(); // 判断容器是否为空
	resize(int num); // 重新指定容器的长度为num，容器中的内容有可能会被删除
	resize(int num,elem);// 若容器边长，用elem填充
	capacity(); // 容器的容量
	reserve(); // 容器预留len个元素长度，预留位置不初始化，元素不可访问
	
	
	// 巧用swap
	vector<int> v;
	for(int i = 0; i < 1000; i++)
	{
		v.push_back(i);
	}
	// 容量可能大于1000，大小为1000
	cout << "v 的容量" << v.capacity() <<endl;
	cout << "v 的大小" << v.size() <<endl;
	
	
	v.resize(3);
	// 大小会变为3，容量不变
	cout << "v 的容量" << v.capacity() <<endl;
	cout << "v 的大小" << v.size() <<endl;
	
	vector<int>(v).swap(v);
	// vector<int>(v) 利用v初始化匿名对象，大小等于v的size
	// swap 交换指针，然后容量就变为3了，之前的就没用了
	// 容量和大小都变为3
	cout << "v 的容量" << v.capacity() <<endl;
	cout << "v 的大小" << v.size() <<endl;
	
	// reserve 预留空间，举个例子
	vector<int> v;
	v.reserve(1000);// 预留出空间
	int *p = NULL;
	int num = 0;
	for(int i = 0;i < 1000;i++)
	{
		v.push_back(i);
		// 统计总共地址空间变化了多少次
		if(p != &v[0])
		{
			p = &v[0];
			num++;
		}
	}
	
	// Num 就是开辟1000个数据用了多少次，
	// 加了reserve(1000),num = 1
	
	
	
	vector 的数据存取操作
	at(int idx);// 返回idx所指的数据，若越界，抛出out_of_range
	operator[]; // 索引，越界直接报错
	front(); //返回容器中第一个数据元素
	back(); //返回容器中最后一个元素
	
	例如：	
		vector<int>v;
		v.push_back(1);
		v.push_back(2);
		v.push_back(3);
		cout << "v.front()" << v.front() << endl;
	
	
	vector容器的插入和删除操作
	insert(const_iterator pos,int cout,ele); // 迭代器指向位置pos插入cout个ele元素
	push_back(elem);// 尾插
	pop_back();// 删除最后一个元素
	erase(const_iterator start, const_iterator end);//删除从start到end之间的元素
	erase(const_iterator pos); //删除迭代器指向的元素
	clear(); // 删除容器中的所有元素。
	
	
	例如：
		v.insert(v.begin(), 2, 4); // 注意第一个是迭代器
		cout << v.front() << endl;
		v.pop_back(); // 删除最后一个 
		v.erase(v.begin()); // 删除第一个
		v.erase(v.begin(),v.end()); // 全部删除了
		v.clear(); //清空所有数据
		
		//逆序遍历
		vector<int> v;
		for(int i = 0; i < 10;i++)
		{
			v.push_back(i);
		}
		
		// 使用逆序遍历迭代器reverse_iterator
		for(vector<int>::reverser_iterator it = v.rbegin();it != v.rend();it++)
		{
			cout << *it <<endl;
		}
		// vector容器支持随机访问
		vector<int>::iterator itBegin = v.begin();
		itBegin = itBegin + 3;
		// 如果上述写法不报错，支持随机访问
	
	
	
	deque容器
	  队列，双向队列，没有容量的概念
	  Deque采取一块所谓的map(映射)作为主控，map为一小块连续的内存空间，
	  其中每一个元素都是一个指针，指向另一段连续性内存空间，称为缓冲区，缓冲区才是deque的存储空间的主体；
	  
	构造函数
	deque<T> deqT;
	deque(beg,end);
	deque(n,elem);
	deque(const deque &deq);
	
	赋值：
	assign(beg,end);
	assign(n,elem);
	deque operator=(const deque& deq);
	swap(deq); // 互换元素。
	
	// 大小
	deque.size(); // 大小
	deque.empty(); // 判断容器是否为空 
	deque.resize(num) ; // 重新指定容器大小，变长默认值填充，变短，超出元素被删除
	deque.resize(num, elem);
	
	// deque数据存取
	at(idx);  // 返回索引，若越界，抛出out_of_range.
	operator[] ;
	front();  // 返回数据的第一个值
	back();   // 返回最后一个数据
	
	
	//插入和删除
	insert(pos, elem);  // 返回新数据的位置
	insert(pos,n,elem); // 在pos位置插入n个elem，无返回值
	insert(pos,beg,end); // 在pos位置插入[beg,end)区间的数据，无返回值
	clear();  // 删除全部
	erase(beg,end);	// 删除[beg,end)区间的数据，返回下一个数据的位置
	erase(pos);  //删除pos位置的数据，返回下一个数据的位置。
	
	// deque 双端插入和删除
	push_back(elem);
	push_front(elem);
	pop_back();
	pop_front();
	
	
	stack 容器
		栈，先进后出，只能访问栈顶，不允许遍历。
		没有遍历，所以没有迭代器。
		
		stack<T> stkT;
		stack(const stack& stack);
		
		stack& operator=(const stack& stk);
		
		push(elem);
		pop();
		top();
		empty();
		size();
		
	
	queue 容器 
	
		先进先出，单向队列，一端进入，另一端取出。
		也没有迭代器
	
		queue<T> queT;
		queue(const queue& que);
		
		push(elem);
		pop();
		back();  // 返回最后一个元素
		push();  // 返回第一个元素
		queue& operator=(const queue& que);
		
		empty();
		size();
		
		
		
	List 容器
	
		list链表，物理存储单元上非连续，非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链次实现的
		
		每一个节点都是包括：节点数据和下一个节点的指针。
		list是一个双向链表。
	
		迭代器： Bldirectional Iteration
		
		双向循环链表
		
		
		构造： 
		list<T> lstT;
		list(beg,end);
		list(n,elem);
		list(const list& lst);
		
		插入/删除
		push_back(elem);
		pop_back();
		push_front(elem);
		pop_front();
		insert(pos,elem);
		insert(pos,beg,end);
		insert(pos,n,elem);
		clear();
		erase(beg,end);
		erase(pos);
		remove(elem);
		
			例子： 
			void pirntList(list<int>&L)
			{
				for(list<int>::iterator it = L.begin();it != L.end();it++)
				{
					cout<<*it<<endl;
				}
			}
			list<int> L(10,10);
			list<int> L2(L.begin(),L.end());
			L2.push_back(100);
			for(list<int>::reverser_iterator it = L2.rbegin(); it != L2/rend(); it++)
			{
				cout<<*it<<endl;
			}
			// 不支持随机访问
			list<int>L3;
			L3.push_front(1);
			L3.push_front(2);
			L3.push_front(3);
			
			L3.pop_back();
			L3.pop_front();
			L3.insert(L3.begin(),12);
			//L3.clear();
			L3.remove(10); // 参数直接放值，删除所有10
			
		大小：
		size();
		empty();
		resize(num);
		resize(num,elem);
		
		赋值：
		assign(beg,end);
		assign(n,elem);
		list oprator=(const list& lst);
		swap(lst);
		
		存取 
		front();  // 返回第一个数据
		back();   // 返回最后一个数据
		
		
		反转排序
		reverse();
		sort();
		// 所有不支持随机访问的迭代器，不可以使用系统提供的算法
		// 那么使用类内部提供的算法
			L3.sort();
			bool myCompare(int v1, int v2)
			{
				return v1 > v2; // 从大到小
			}
			L3.sort(myCompare);
			
			// 对于自定义的数据类型，必须指定排序规则
			// 如果年龄相同，按身高排序
			bool myComparePerson(Person& p1, Person& p2)
			{
				/*
				if(p1.m_Age > p2.m_Age)
				{
					return true;
				}
				return false;
				*/
				if(p1.m_Age == p2.m_Age)
				{
					return p1.m_Height < p2.m_Height;
				}
				else
				{
					return p1.m_Age > p2.m_Age;
				}
			}
			
			for(list<Person>::iterator it = L.begin(); it != L.end();it++)
			{
				cout<<it->m_Height<<end;
				cout<<it->m_Name<<it->m_Age<<endl;
			}
		// 使用remove删除自定义类型
		// 需要重载==
		bool operator==(const Person &p)
		{
			if(this->m_Name == p.m_Name)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
	
	
	Set 容器 
	
	set/multiset ：特征是所有元素都会根据元素的键值自动被排序。set元素不像map那样可以同时拥有实值和键值，
	set的元素既是键值又是实值。Set不允许两个元素有相同的键值。
	不能通过迭代器改变set的元素值。因为set元素值就是其键值。所以set的迭代器是const_iterator
	
	multiset 与set 的唯一区别就是它允许键值重复，set和multiset实现底层是红黑树，是平衡二叉树的一种。
	
	
	红黑树：树的左边比根小，树的右边比根大。
	
	平衡二叉树：所有左子节点与右子节点的插值不能大于1
	
	构造函数：
	set<T> st;
	multiset<T> mst;
	set(const set& st);
	
	赋值运算
	set& operator=(const set& st);
	swap(st);
	
	大小
	size();
	empty();
	
	插入和删除
	insert(elem);
	clear();
	erase(pos);
	erase(beg,end);
	erase(elem);
	
		例子：
		void printSet(set<int> & s)
		{
			for(set<int>::iterator it = s.begin();it != s.end();it++)
			{
				cout << *it << endl;
			}
		}
		set<int> s1;
		
		s1.insert(10);
		s1.insert(2);
		s1.insert(13);
		s1.insert(41);
		s1.insert(5);
		// 关联式容器，key自动排序，从小到大
		if(!s1.empty())
		{
			cout << " size :" << s1.size() << endl;
		}
		s1.erase(s1.begin());
		s1.erase(5);
	
	
	查找操作：
	find(key); // 查找key是否存在，若存在返回对应元素迭代器，不存在，返回set.end()
	count(key); // 查找键key的元素个数
	lower_bound(keyElem); // 返回第一个key >= KeyElem元素的迭代器
	upper_bound(keyElem); // 返回第一个key > keyElem元素的迭代器
	equal_range(keyElem); // 返回容器中key与keElem相等的上下限的两个迭代器
	
		例子：
		// 对于set而言，value = key 
		set<int>::iterator pos = s1.find(3);
		if(pos != s1.end())
		{
			cout << "找到，值为：" << *pos <<endl;
		}
		else
		{
			cout << "没找到" << endl;
		}
		// count(key) 查找元素个数，set的结果为1或0
		int num = s1.count(41);
		
		set<int>::iterator it = s1.lower_bound(10);
		if(it != s1.end())
		{
			cout << "找到了，值：" << *it <<endl;
		}
		else
		{
			cout << "没找见" << endl;
		}
		
		set<int>::iterator it2 = s1.upper_bound(21);
		
		// 上下限的两个值就是lower_bound()和upper_bound() 两个值
		pair<set<int>::iterator,set<int>::iterator> ret = s1.equal_range(21);
		// 对组
		if(ret.first != s1.end())
		{
			cout << " 找到了，第一个值为：" << *(ret.first) << endl;
		}
		else
		{
			cout << "没找见" << endl;
		}
		
		if(ret.second != s1.end())
		{
			cout << " 找到了，第二个值为：" << *(ret.second) << endl
		}
		else
		{
			cout << "没找见" << endl;
		}
	
		// 对组 pair 
		// 创建对组
		// 第一种： 
		pair<string, int> p(string("Tom",100));
		// 取值 
		cout << " 第一个值" << p.first << endl;
		cout << " 第二个值" << p.second << endl;
		
		// 第二种 
		pair<string, int> p2 = make_pair("Jerry",10);
		
		
		// set不允许插入重复的键值
		set<int> s;
		s.insert(10); // 返回pair类型的数据
		pair<set<int>::iterator,bool> ret = s.insert(10);
		
		// 排序(从大到小)，排序在插入之前指定
		// 指定排序规则 ，参数是类型，函数不是类型,仿函数
		class myCompare
		{
			public:
			bool operator()(int v1, int v2)
			{
				return v1 > v2;
			}
		}
		set<int, myCompare>s1;
		s1.insert(1);
		s1.insert(2);
		
		// 自定义数据类型
		
		class myComparePerson
		{
			public:
			bool operator()(const Person& p1, const Person& p2)
			{
				if(p1.m_Age > p2.m_Age)
				{
					return true;
				}
				return false;
			}
		}
		set<Person, myComparePerson> s1;
		Person p1("Tom",10);
		Person p2("Jerry",9);
		Person p3("Horn",8);
		// 插入之前，要指定排序规则
		
		s1.insert(p1);
		s1.insert(p2);
		s1.insert(p3);
		
		
	Map/multimap 容器 
		
	所有的元素都会根据元素的键值自动排序，Map所有的元素都是pair，同时拥有实值和键值，
	pair的第一元素值为键值，第二元素值为实值，Map不允许两个元素有相同的键值
	
	不可以通过map的迭代器修改map的键值，键值关系到map容器的排序规则，修改键值
	将严重破坏map组织，修改元素的实值是可以的。
	
	
	map与list有一些相同特性，删除某些元素，之前的元素没有影响。
	map/multimap 的唯一区别，后者允许重复键值
	实现底层是红黑树
	
	
	
	API
	
		构造：
		map<T1,T2>mapTT;
		map(const map& mp);
		赋值：
		map& operator=(const map& mp);
		swap(mp);
		
		大小：
		size();
		empty();
		插入 
		map.insert(...);// 在容器中插入元素，返回pair<iterator,bool>
		map<int,string>mapStu;
		//第一种：
		  //通过pair的方式插入对象
		  mapStu.insert(pair<int,string>(3,"Tom"));
		// 第二种，通过pair的方式插入对象
		  mapStu.insert(make_pair(-1,"Jerry"));
		// 第三种：通过value_Type的方式插入对象
		  mapStu.insert(map<int,string>::value_type(1,"Horn"));
		// 第四种： 通过数组的方式插入值 
		  mapStu[3] = "Luo";
		  mapStu[4] = "hat"
		
		删除 
		clear();
		erase(pos); // 删除pos迭代器所指的元素，返回下一个元素的迭代器
		erase(beg,end);
		erase(keElem); // 删除容器中key为keyElem的对组 
		
		查找：
		find(key);	 // 查找key是否存在，不存在返回map.end();存在返回元素对应迭代器
		count(keyElem); // 查找key为keyElem对组的个数 
		lower_bound(keyElem); //返回第一个key >= keyElem 的迭代器
		upper_bound(keyElem); //返回第一个key > keyElem 的迭代器
		equal_range(keyElem); //返回容器中 key与keElem相等的上下限的两个迭代器
		
		// 排序方式与set的方式一样
		
		
		
		
		
*****************   DAY 12   *****************		
		
常用算法
	
		
	函数对象： 仿函数， 重载() 
		
		1. 函数对象是一个类
		2. 函数对象重载了(),使得类可以像函数一样调用
		
	一元仿函数：假定一个类重载了(), 而且重载operator()要求输入一个参数operator()(int num)
	二元仿函数：operator()(int num, int weight)
	
	仿函数的作用就是改变STL中算法的策略，通过template参数的形式指定策略
	
	仿函数的调用；
		class print{};
		1. print();
		2. print()(); // 匿名对象的方式调用
	
	仿函数，超出函数范围，可以内部保存状态
	class myprint{
	public:
		int num = 0;
		void operator()
		{
			cout << "HAHAHA" <<endl;
			num++; // 可以统计出调用了多少次
		}
	}
	
	函数对象可以作为参数；
	void dowork(myprint pr, int num)
	{
		pr();
	}

	// 总结： 
			函数对象通常不定义构造和析构，所以在构造和析构时不会发生任何问题，避免了函数调用的运行问题
			函数对象可以内联编译，效率高
			模板函数对象具有通用性
			可以有自己的状态，超出函数范围




	谓词 ：
	
		谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果
		operator接受一个参数，那么叫做一元谓词，如果接受两个参数，叫做二元谓词。
		谓词可以做为一个判断式。
		
		vector<int> v;
		v.push_back(10);
		v.push_back(20);
		v.push_back(30);
		v.push_back(40);
		
		class Greaterthan20
		{
		public:
			bool operator()(int val)
			return val > 20;
		}
		
		// 第三个参数是函数对象，匿名对象
		vector<int>::iterator pos = find_if(v.begin(),v.end(),Greaterthan20());
		if(pos != v.end())
		{
			cout << "找到对应内容" << *pos <<end; 
		}
		// 二元谓词
		class MyCompare
		{
			public:
			bool operator()(int v1, int v2)
			{
				return v1 > v2;
			}
		}
		
		sort(v.begin(),v.end(),MyCompare());
		// 匿名函数， lambda表达式 [](){}  :[]标识符，() 参数，{}实现
		
		for_each(v.begin(),v.end(),[](int val){cout << val << " ";})
		
		
		内建函数对象
		
		STL内建了一些函数对象，分为算法类函数对象，关系运算类函数对象，逻辑运算类仿函数等
		引入头文件 #include<functional>
		template<class T> T plus<T> // 加法仿函数
		template<class T> T minus<T> // 减法仿函数
		
		
		例子：	
			#incloude<functional>
			#include<algorithm>
			#include<vector>
			
			negate<int> n;
			cout << n(10) << endl;   // 结果-10
			
			plus<int>p;
			cout << p(1,1) << endl; // 结果为2
			
			//关系运算符 
			vector<int> v;
			v.push_back(1);
			v.push_back(2);
			v.push_back(3);
			
			sort(v.begin(),v.end(),greater<int>());
			
			for_each(v.begin(),v.end(),[](int val){cout << val << endl;})
			
		
		适配器： 修饰仿函数
		
			#include<vector>
			#include<algorithm>
			#include<functional>
			#include<string>
			// 第一步，绑定 数据 bind2nd
			// 第二步，仿函数继承binary_function<第一个参数，第二个参数，返回值>
			// 第二步，加const修饰函数
			
			class MyPrint : binary_function<int,int,void>
			{
				void operator()(int val,int num) const
				{
					cout << val + num << endl;
				}
			}
			vector<int>v;
			for(int i = 0; i < 10; i++)
			{
				v.push_back(i);
			}
			int num;
			cin >> num;
			
			for_each(v.begin(),v.end(),bind2nd(MyPrint(),num));
			for_each(v.begin(),v.end(),bind1st(MyPrint(),num));// 与上面区别是参数位置
		
		
			// 取反适配器
		
			class Greaterthan5：public unary_function<int,bool>
			{
				// 一元取反
				public:
				bool operator()(int val) const
				{
					return val > 5;
				}
			};
			// 查找大于5的数字
			vector<int>::iterator pos = find_if(v.begin(),v.end(),Greaterthan5());
			// 查找小于5的数字, not1 就是一元取反的意思
			vector<int>::iterator pos = find_if(v.begin(),v.end(),not1(Greaterthan5()));
			// 与上述的操作一样
			vector<int>::iterator pos = find_if(v.begin(),v.end(),not1(bind2nd(greater<int>(),5)));


			函数指针适配器
			void MyPrint<int v, int start>
			{
				cout << v + start << " ";
			}
			vector<int>v;
			for(int i = 0; i < 10;i++)
			{
				v.push_back(i);
			}
			for_each(v.begin(),v.end(),MyPrint);
			// 将函数指针适配为 函数对象 ,然后绑定
			for_each(v.begin(),v.end(),bind2nd(ptr_fun(MyPrint),100));

			
			
			
			成员函数适配器
			class Person{
			public:
				Person(string name,int age)
				{
					this->m_Name = name;
					this->m_Age = age;
				}
				void showPerson()
				{
					cout << "成员函数适配器打印。。。" << endl;
					cout << "姓名：" << p.m_Name << ",年龄：" << p.m_Age <<endl;
				}
				void plusAge()
				{
					this->m_Age = this->m_Age + 100;
				}
				string m_Name;
				int m_Age;
			};
			
			void MyPrintPerson(Person& p)
			{
				cout << "姓名：" << p.m_Name << ",年龄：" << p.m_Age <<endl;
			}
			vector<Person> v;
			Person p1("Tom",10);
			Person p2("Jerry",9);
			Person p3("Horn",11);
			v.push_back(p1);
			v.push_back(p2);
			v.push_back(p3);
			
			for_each(v.begin(),v.end(),MyPrintPerson);
			// 成员函数的适配器
			// mem_fun_ref
			for_each(v.begin(),v.end(),mem_fun_ref(&Person::showPerson));
			for_each(v.begin(),v.end(),mem_fun_ref(&Person::plusAge));

			// 如果是指针 vector<Person*>v1; Person p1("Tom",10);v1.push_back(&p1);
			// mem_fun


	算法 
	主要有 头文件<algorithm> <functional> <numeric>
		
		常用的遍历算法
		for_each(iterator.begin(),iterator.end(),_callback);
		
		// 有返回值，比如_callbak调用次数
		// for_each 绑定参数输出 


		// 将指定容器区间元素搬运到零一容器中
		// transform不会给目标容器分配内存，所以需要提前分配内存
		transform(iterator.beg1,iterator.end1,iterator.beg2,_callback)
		
		// 回调函数可以提供策略，比如搬运过程中增加10
		class TransForm
		{
		public:
			int operator()(int val)
			{
				return val+10;
			}
		}
		vector<int>v;
		for(int i = 0;i < 10;i++)
		{
			v.push_back(i);
		}
		vector<int>vTarget; // 目标容器
		vTarget.resize(v.size()); // 注意一定要分配内存
		transform(v.begin(),v.end(),TransForm());
		for_each(vTarget.begin(),vTarget.end(),[](int val){cout << val << " "; });
		
		// 将两个容器相加搬运到另一个容器
		class TransForm
		{
		public:
			int operator()(int val1, int val2)
			{
				return val1 + val2;
			}
		}
		vector<int>v1;
		vector<int>v2;
		for(int i = 0;i < 10;i++)
		{
			v1.push_back(i);
			v2.push_back(i+10);
		}
		vector<int>vTarget;
		vTarget.resize(v1.size());
		transform(v1.begin(),v1.end(),v2.begin(),vTarget.begin(),TransForm());;
		for_each(vTarget.begin(),vTarget.end(),[](int val){cout << val << " "; });


	常用的查找算法
	find(beg, end, value); 返回查找元素的位置
	find_if(beg, end, 仿函数);
	adjacent_find(beg,end,_callback); // 查找相邻重复元素
	// 返回重复元素的第一个迭代器位置，序列中使用
	
	bianry_search(beg, end, value);// value为查找的值
	// 返回bool类型，true找到，false没找到
	必须在有序序列中使用，二分查找法，
	
	
	count(beg,end,value); 统计元素出现的次数
	count(beg,end,_callback); 回调函数或者谓词(bool类型的函数对象)
	
	
	常用的排序算法 
	merge算法，容器元素合并，并存储到另一个容器中
	merge(beg1,end1,beg2,end2,dest);// 容器1和容器2的范围，dest目标容器开始迭代
	
	sort(beg,end,_callback); // 容器元素排序
	// 两个元素必须是有序的
	
	random_shuffle(iteratorbegm iterator end);// 洗牌
	
	reverse(beg, end);  // 翻转
	
	
	
	常用的拷贝算法
	
	copy(beg, end, dest); 目标容器起始迭代器
	
	// 将容器中质地的那个范围的元素替换为新元素
	replay(beg, end, oldvalue, newvalue);
	replay_if(beg, end, _callback, newvalue);
	
	
	// 交换容器
	swap(v1, v2);
	
	
	// 常用的生成算法
	accumulate 算法，计算容器元素累计总和
	accumulate(beg,end,value); // value 为起始累加值，返回的总和
	
	
	fill 向容器中添加元素
	fill(beg, end, value); // value 添加元素
	
	
	
	常用的集合算法
	//求2个set集合的交集
	set_intersection(beg1, end1, beg2, end2, dest ) ；
	// 返回目标容器的最后一个元素的迭代器地址
	
	set_union() ； 求2个set集合的并集
	set_difference(); 求2个set集合的差集
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	














