
# 小整数对象池

#   避免为整数频繁申请和销毁内存空间，python对小整数的定义是[-5,257）这些整数对象是提前建立的，
#   不会被垃圾回收，在一python程序中，所有位于这个范围内的整数使用的都是同一个对象
#   同理，单个字母也是一样的


# 大整数对象池

#   小整数对象池之外的全部



# intern 机制

#   中间没有特殊字符(-/ )的string，共用一份内存，用引用区分 


#总结  小整数对象池共用对象，单字符共用对象，常驻内存。intern 机制


# Garbage collection (GC垃圾回收)
"""
    python 采用的是引用计数机制为主，标记-清除和分代收集为辅的策略
    python 里面每一个东西都是对象，它的核心就是一个结构体。
	
	typedef struct_object{
		int ob_refcnt;
		struct_object *ob_type;
	}PyObject;
	
	PyObject 是每个对象必有的内容，其中ob_refcnt就是作为引用计数。当一个对象有新的引用时，它的
	ob_refcnt 就会增加，当引用它的对象被删除时，它的ob_refcnt就会减少。
	
	
	优点：简单，没有引用就释放内存。
	缺点：维护消耗资源，相互引用的无法解决

		GC 的工作 -- 跳动的心脏 
	###  为新生的对象分配内存
	###  识别那些垃圾对象
	###  从垃圾对象那回收内存
	
	标记-清除
	
	   python在创建对象时，会向内存申请
	  有对象的标记一下，没被用的回收掉
	
	隔代回收 Generation Zero
	
	创建一张双向链表，链表中增加对象，出现循环引用时，
	
	Generation Zero 初始值为1
	
	引用计数  1				  1					 2
	 0代 <----> List1  <- --- >  List2  <-----  --> List3  <--->   （新创建对象）
	 
	 达到某种场景，首先要判断有没有互相引用，有的会对链表中的引用-1，没有引用的-1，就会变为0.那么删除掉为0 
	 然后生成第二条链子（清理N次）
	  1代   
	 <----> List1  <- --- >  List2  <-----  --> List3  <--->   
      2代（清理N次）
	  
	   <----> List1  <- --- >  List2  <-----  --> List3  <--->

	#gc.get_count()  返回的值，表示三代当前的值
	#gc.get_threshold()  返回的是三代的阈值，触发（新创建对象-已释放的对象 > 阈值，清理10次0代了，就清理1次1代(顺便清理1次0代)）
	#gc.set_threshold()
	
	
	
	# 引用+1 ： 创建对象，=，传入参数，容器存储如list
	# 引用-1 ： 对象别名被显示摧毁 del a， 对象的别名被赋予新对象 a = 24, 对象离开作用与，对象所在的容器被销毁，或从容器中删除对象
	
	# sys.getrefcount() 查看对象引用。
	# gc.collect()
	# gc.garbage  打印出来清除的列表
	
	# 如果在类中 重写 了 __del__(self),将会清除不掉，所以做完自己的，再次调用父类的方法
"""   




      

















